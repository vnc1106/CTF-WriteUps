# Living Without Expectations

> `Sometimes you just gotta have some fun implementing bare hardness assumptions.`\
> **(10 solves, 492 points)**\
> **Attachmets: [lwe.py](./challenge/lwe.py) [output.txt](./challenge/output.txt)**

## Challenge overview

The script generates a secret $69$-dimension vector $s$ with elements $0$ or $1$. They encrypt the flag by looping for each bit of the flag:
* Firstly, generate a random $69 \times 69$ matrix $A$, with elements $< q$.
* If the flag bit is $0 \Rightarrow $ return $b = A \times s + e \text{ (mod q)}$, where $e$ is an error vector with elements $<7$
* If the flag bit is $1 \Rightarrow $ return a random vector $b$ with elements $< q$

## Solution

Firstly we known that the flag start with $\text{ictf}$, so the first bit must be $0$, so we extract the first line of `output.txt`, then have a pair of value $(A, b)$ such that:
$$b = A \times s + e \quad \text{(mod q)} \qquad (1)$$

Let:

$$A = \begin{bmatrix}
a_{11} & a_{12} &\cdots & a_{1n}  \\\\
a_{21} & a_{22} &\cdots & a_{2n}  \\\\
\vdots & \vdots &\ddots & \vdots  \\\\
a_{n1} & a_{n2} &\cdots & a_{nn}  \\\\
\end{bmatrix}, \quad b = 
\begin{bmatrix}
b_{1} \\\\ b_{2} \\\\ \vdots \\\\ b_{n}
\end{bmatrix}, \quad e = 
\begin{bmatrix}
e_{1} \\\\ e_{2} \\\\ \vdots \\\\ e_{n}
\end{bmatrix}, \quad s = 
\begin{bmatrix}
s_{1} \\\\ s_{2} \\\\ \vdots \\\\ s_{n}
\end{bmatrix}
$$

Then we build the basis:

$$B =
\begin{bmatrix}
1       & 0        & \cdots & 0 & a_{11} & a_{21} & \cdots & a_{n1} \\\\
0       & 1        & \cdots & 0 & a_{12} & a_{22} & \cdots & a_{n2} \\\\
\vdots  & \vdots   & \ddots & 1 & a_{1n} & a_{2n} & \cdots & a_{nn} \\\\
0       & 0        & \cdots & 0 & k_{1}  & 0      & \cdots & 0      \\\\
0       & 0        & \cdots & 0 & 0      & k_{2}  & \cdots & 0      \\\\
\vdots  & \vdots   & \ddots & 0 & 0      & 0      & \ddots & k_{n}  \\\\
0       & 0        & \cdots & 0 & -b_{1}  & -b_{2} & \cdots & -b_{n}
\end{bmatrix}$$

We see that there is a small vector

$$v = (s_{1}, s_{2}, \cdots, s_{n}, e_{1}, e_{2}, \cdots, e_{n})$$

generated by this basis. So we just applying **LLL algorithm** to reduce basis $B$, then find the secret vector $s$. With $s$ we easily decrypt the flag 
by checking

$$b - A \times s \qquad \text{(mod q})$$

is a small vector or not!

[Final script](./sol.py)
